ส่วนที่ 2 int

2.1 สังเกตผลจากการรันโค้ดในส่วน 2.1 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
คำตอบ ตรงตามหลักการ เพราะค่า `100` อยู่ในขอบเขตที่ int 32-bit รองรับได้

2.2 สังเกตผลจากการรันโค้ดในส่วน 2.2 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
คำตอบ ตรงตามหลักการ เพราะ `2147483647` เป็นค่าสูงสุดที่ int เก็บได้พอดี

2.3 สังเกตผลจากการรันโค้ดในส่วน 2.3 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
คำตอบ ไม่ตรงตามหลักการ เพราะเกินค่าสูงสุด → เกิด Overflow ทำให้ค่ากลับไปเป็น -2147483648

2.4 สังเกตผลจากการรันโค้ดในส่วน 2.4 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
คำตอบ ตรงตามหลักการ เพราะ `-2147483648` เป็นค่าต่ำสุดที่ int เก็บได้พอดี

2.5 สังเกตผลจากการรันโค้ดในส่วน 2.5 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
คำตอบ ไม่ตรงตามหลักการ เพราะต่ำกว่าขอบเขต → เกิด Underflow ทำให้ค่ากลับไปเป็น 2147483647

ส่วนที่ 3 float และ double

3.1 คุณสังเกตเห็นความแตกต่างของความแม่นยำระหว่าง float และ double อย่างไร?
คำตอบ float แม่นยำประมาณ 6–7 หลัก ส่วน double แม่นยำได้ถึง 15–16 หลัก

3.2 สถานการณ์ใดที่คุณควรเลือกใช้ double แทน float?
คำตอบ ใช้ double เมื่อการคำนวณต้องการความแม่นยำสูง เช่น วิทยาศาสตร์ การเงิน หรือวิศวกรรม

ส่วนที่ 4 char

4.1 ค่าตัวเลข (ASCII value) มีความสัมพันธ์กับอักขระอย่างไร?
คำตอบ ตัวเลขคือรหัสที่แทนตัวอักขระ เช่น ‘Z’ = 90, ‘z’ = 122 ตามตาราง ASCII

4.2 ถ้าอยากทราบความสัมพันธ์ระหว่างตัวเลขกับอักขระทั้งหมด สามารถหาได้จากเอกสารใด หรือแหล่งอ้างอิงใด
คำตอบ หาได้จากตาราง ASCII (ASCII Table)

4.3 จากข้อ 4.2 นักเขียนโปรแกรมสามารถกำหนดขึ้นเองได้ หรือมีเอกสารใดกำกับอยู่
คำตอบ ไม่สามารถกำหนดเองได้ เพราะตาราง ASCII เป็นมาตรฐานสากลที่ถูกกำหนดไว้แล้ว

ส่วนที่ 5 bool

5.1 true และ false ถูกแสดงผลเป็นค่าใดบน Serial Monitor?
คำตอบ true แสดงเป็น 1, false แสดงเป็น 0

ส่วนที่ 6 long และ unsigned

6.1 บน ESP32, long มีขอบเขตเท่ากับ int หรือไม่?
คำตอบ เท่ากัน เพราะทั้ง long และ int เป็นชนิดข้อมูล 32-bit

6.2 ชนิดข้อมูลใดที่ต้องใช้หากต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุด?
คำตอบ unsigned long long (64-bit)

ส่วนที่ 7 byte

เมื่อ myByte ถูกกำหนดให้เป็น 256 ผลลัพธ์ที่ได้คืออะไร และเพราะเหตุใด?
คำตอบ ผลลัพธ์เป็น 0 เพราะ byte เก็บได้เพียง 0–255 และเมื่อเกินขอบเขตจะเกิด Overflow ทำให้ค่ากลับไปเริ่มใหม่ที่ 0
